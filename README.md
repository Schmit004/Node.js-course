**Node.js** — это среда выполнения JavaScript, построенная на движке V8 от Google Chrome, которая позволяет запускать JavaScript вне браузера, а так же библиотеки **libuv**, отвечающей за кроссплатформенный I/O и цикл событий (event loop). Node.js используется для создания серверных приложений и обладает следующими ключевыми характеристиками:
- **Асинхронная, событийно-ориентированная архитектура**: Node.js использует неблокирующую модель ввода-вывода, что позволяет обрабатывать большое количество одновременных соединений эффективно.
- **Однопоточная модель с поддержкой многозадачности**: Хотя Node.js работает в одном потоке, он может обрабатывать множество операций одновременно благодаря своей асинхронной природе.
- **Модульная система**: Node.js использует систему модулей, что позволяет легко управлять зависимостями и повторно использовать код.
Node.js широко используется для разработки серверных приложений, API, микросервисов и реальных приложений с высокой нагрузкой.

[Ссылка](https://Node.js.org/dist/latest-v18.x/docs/api/) на официальную документацию.

## Основы

### V8

Движок V8 отвечает за интерпретацию JavaScript кода, а так же JIT-компиляцию наиболее часто используемых участков кода, в рамках повышения производительности.
Помимо этого V8 отвечает за работу с памятью и реализацию управления коллстеком в соответствии со спецификацией ECMAScript.

### libuv

Выше уже было указано что данная библиотека отвечает за кроссплатформенный, асинхронный I/O и цикл событий. Этот цикл событий отличается от того, который реализован в браузере, т.к. в нём отсутствуют очереди макро- и микрозадач.
Для реализации цикла событий в Node.js используется архитектурный шаблон Reactor.

#### Основные компоненты шаблона Reactor
1. **Event Demultiplexer**
Компонент, который ожидает появления событий ввода-вывода, таких как готовность файловых дескрипторов для чтения или записи, завершение таймеров, сетевые события и т.д.
Когда событие происходит, Event Demultiplexer распределяет его к соответствующему обработчику событий (event handler).

2. **Event Loop**
Цикл, который непрерывно проверяет наличие событий и передает их для обработки соответствующим обработчикам.
Цикл событий (Event Loop) в Node.js — это бесконечный цикл, который непрерывно повторяет определенные фазы для обработки событий. На каждой итерации цикла событий проходят определённые фазы ,которые повторяются пока есть события для обработки.

    _Фазы цикла событий_:
    - **Timers**:
В этой фазе обрабатываются коллбэки, зарегистрированные с помощью setTimeout и setInterval.
Когда время истекает, соответствующий коллбэк добавляется в коллстек для выполнения.
    - **Pending Callbacks**:
В этой фазе обрабатываются коллбэки, отложенные до следующей итерации цикла событий.
Например, некоторые системные коллбэки, такие как ошибки TCP.
Когда коллбэк готов к выполнению, он добавляется в коллстек.
    - **Idle, Prepare**:
Внутренние фазы, используемые libuv для подготовки к следующей фазе. Они не имеют прямого отношения к обработке пользовательских событий.
    - **Poll**:
Это основная фаза, где цикл событий проверяет наличие новых событий ввода-вывода и обрабатывает их.
Если нет событий ввода-вывода, эта фаза может блокировать выполнение до появления новых событий.
    - **Check**:
Обрабатывает коллбэки, зарегистрированные с помощью setImmediate.
Когда setImmediate коллбэк готов к выполнению, он добавляется в коллстек.
    - **Close Callbacks**:
Обрабатывает закрывающие коллбэки, такие как socket.on('close').
Когда закрывающий коллбэк готов к выполнению, он добавляется в коллстек.

3. **Event Handlers**:
Обработчики событий, которые выполняются при возникновении событий.
В Node.js это функции-коллбэки, которые передаются в асинхронные операции.
В Node.js коллбэки организованы в списки или очереди по типам событий, и каждый тип списка привязан к соответствующей фазе цикла событий (event loop). На каждой фазе цикла событий (event loop) выполняются все коллбэки, которые готовы к выполнению в этой фазе, до тех пор, пока не истечет определенное время или пока не будут выполнены все коллбэки в очереди. В некоторых случаях, если выполнение коллбэков занимает слишком много времени, цикл событий может ограничить время, проведенное в одной фазе, и перейти к следующей фазе, чтобы избежать блокировки других операций.

---

### npm

При установке Node.js на ПК, вместе с ним так же устанавливается **Node Package Manager (npm)**.
**npm** — это пакетный менеджер для JavaScript, который используется для управления зависимостями в проектах, работающих с Node.js. Он позволяет разработчикам:
- **Устанавливать** и **управлять** библиотеками и фреймворками, которые можно использовать в своих проектах.
- **Публиковать** и **делиться** собственными пакетами с сообществом.
- **Автоматизировать** различные задачи, такие как сборка и тестирование, с помощью скриптов.

Для установки зависимостей в свой проект, необходимо инициализировать проект, т.е. создать начальную структуру и необходимые файлы для разработки.
Инициализация выполняется командой `npm init`, или `npm init -y` чтобы использовать стандартные настройки.
В процессе инициализации создаётся файл _package.json_.
Этот файл содержит метаданные о проекте: имя, версия, автор, лицензия и т.д.
Так же в нём отображается список зависимостей, которые используются в проекте и скрипты, которые можно запускать с помощью npm (например, start, test).

---

### Зависимости

**Зависимости (dependencies)** — это внешние библиотеки, фреймворки, или модули, которые ваш проект использует для выполнения определенных функций или задач. Вместо того чтобы писать весь код с нуля, разработчики могут использовать уже существующие решения, что позволяет сэкономить время и усилия.

#### Типы зависимостей
**Основные зависимости (dependencies)**:
Это библиотеки и модули, которые необходимы для работы вашего приложения в производственной среде.
Они указываются в разделе "dependencies" файла _package.json_.

**Разработческие зависимости (devDependencies)**:
Это инструменты и библиотеки, которые нужны только в процессе разработки, тестирования и сборки проекта, но не требуются в производственной среде.
Они указываются в разделе "devDependencies" файла _package.json_.

#### Управление зависимостями с помощью npm
**Просмотр установленных зависимостей**:
Для просмотра всех установленных зависимостей используйте команду `npm list`.

**Установка зависимостей**:
- Для установки основной зависимости используйте команду `npm install <package-name>`.
- Для установки разработческой зависимости используйте команду `npm install <package-name> --save-dev`.
- Для установки конкретной версии пакета, используйте команду `npm install <package-name>@<version>`.
Дополнительно можно указать диапазоны версий (подробнее ниже) для обновления, в процессе установки:
- `npm install express@~4.17.1` - будет обновляться в рамках патч версий.
- `npm install express@^4.17.1` - будет обновлятся в рамках минорных и патч версий (используется по умолчанию).
- `npm install express@4.17.1` - установка фиксированной версии, без возможности обновления.
- `npm install express@>=4.17.1 <5.0.0` - возможно обновление в диапазоне от 4.17.1(включительно), до 5.0.0.

При установке любой зависимости в рабочей директории появляется папка **node_modules**, в которой собственно и хранятся используемые зависимости. А так же добавляется файл _package-lock.json_, содержащий полное древо зависимостей. Иначе говоря в нём отображены зависимости устанавливаемых зависимостей.

**Удаление зависимостей**:
Для удаления зависимости используйте команду `npm uninstall <package-name>`.

**Обновление зависимостей**:
Для обновления _всех_ зависимостей до последних версий используйте команду `npm update`.
Для обновления конкретного пакета в проекте, вы можете использовать команду `npm update <package-name>`.
Вышеуказанные команды выполняют обновление до последней версии в рамках текущего диапазона версий.
Однако, чтобы обновить пакет до последней версии, часто используется команда `npm install <package-name>@latest`.

#### Семантическое версионирование (semver)

Любое обновление зависимостей выполняется согласно диапазону версий, указанному в _package.json_. Этот диапазон версий определяется с помощью семантического версионирования (semver).

Семантическое версионирование использует формат `MAJOR.MINOR.PATCH`, где:

- **MAJOR** (мажорная версия): Вносит несовместимые изменения API.
- **MINOR** (минорная версия): Добавляет новые функции, совместимые с предыдущими версиями.
- **PATCH** (патч-версия): Вносит исправления ошибок, совместимые с предыдущими версиями.

**Диапазоны версий в package.json**

При указании версий в _package.json_ можно использовать различные символы и символические обозначения для определения диапазона версий:

1. **Тильда (`~`)**:
- Обновления только патч-версий.
- Пример: `"express": "~4.17.1"` будет обновлено до `4.17.x`, но не до `4.18.0`.

2. **Каретка (`^`)**:
- Обновления минорных и патч-версий.
- Пример: `"express": "^4.17.1"` будет обновлено до `4.x.x`, но не до `5.0.0`.

3. **Фиксированная версия**:
- Обновления не производятся.
- Пример: `"express": "4.17.1"` будет использовать только версию `4.17.1`.

4. **Диапазоны версий**:
- Можно указать конкретные диапазоны версий.
- Пример: `"express": ">=4.17.1 <5.0.0"`.

Команды `npm update` и `npm install <package-name>@latest` автоматически обновят запись в файле `package.json` с новой версией пакета, если она соответствует указанному диапазону версий.

Можно изменить диапазон версий для уже установленной зависимости, вручную отредактировав файл _package.json_ и затем выполнив команду`npm install`, чтобы применить изменения.

---

### Втроенные библиотеки

Node.js поставляется с обширным набором встроенных библиотек, которые предоставляют широкий спектр функциональности для разработки серверных приложений. Эти библиотеки позволяют выполнять различные задачи, такие как работа с файловой системой, создание сетевых серверов и клиентов, управление потоками данных и многое другое.
Подробнее о каждой библиотеке смотреть информацию в директории _libs_ текущего проекта.

---

### Запуск JavaScript кода

Для запуска JavaScript кода, нужном файле с помощью Node.js необходимо сделать следующее:
- перейти в директорию с нужным файлом;
- вызвать команду `node filename.js`;
- либо указать путь до исполняемого файла из текущей директории `node путь/к/файлу`.

Примечание. Не забыть сохранить код в нужном файле, чтобы Node.js запускал актуальный код.

#### Аргументы
При запуске Node.js-скриптов им можно передавать аргументы. Вот обычный вызов скрипта:
```bash
node app.js
```

Передаваемые скрипту аргументы могут представлять собой как самостоятельные значения, так и конструкции вида ключ-значение. В первом случае запуск скрипта выглядит так:
```bash
node app.js flavio
```

Во втором — так:
```bash
node app.js name=flavio
```

От того, какой именно способ передачи аргументов используется, зависит то, как с ними можно будет работать в коде скрипта. Подробнее в директории ./process, в файле README.md.

Полезные _bash_ команды:
- `ls` - проверяет список файлов в текущей директории;
- `cd путь/к/вашей/директории` - перемещает в указанную директорию;
- `node -v` - проверяет наличие Node.js на ПК и её версию.

### REPL

Аббревиатура REPL расшифровывается как Read-Evaluate-Print-Loop (цикл «чтение — вычисление — вывод»). Это среда, которая читает пользовательский ввод, выполняет этот ввод как код и выводит результат операции. В контексте Node.js REPL является интерактивной средой исполнения кода JavaScript, которая позволяет разработчикам быстро тестировать и отладить фрагменты кода в режиме реального времени.Использование REPL — это отличный способ быстрого исследования возможностей Node.js.

Как вы уже знаете, для запуска скриптов в Node.js используется команда node, выглядит это так:

```bash
node script.js
```

Если ввести такую же команду, но не указывать имя файла, Node.js будет запущен в режиме REPL:

```bash
node
```
Node.js теперь находится в режиме ожидания. Система ждёт, что мы введём в командной строке какой-нибудь JavaScript-код, который она будет выполнять. Например:

```javascript
> console.log('test')
test
undefined
>
```
Надо отметить, что REPL распознаёт ввод многострочных выражений и без использования команды `.editor`.

Например, мы начали вводить код итератора:
```javascript
[1, 2, 3].forEach(num => {
...
```
Если, после ввода фигурной скобки, нажать на клавишу Enter, REPL перейдёт на новую строку, приглашение в которой будет выглядеть как три точки.

Режим REPL — полезная возможность Node.js, но область её применения ограничена небольшими экспериментами.
